\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[spanish,es-noindentfirst]{babel}
\usepackage{graphicx}
%Code Highlighting
%He tenido que quitar el Minted porque me daba error
\usepackage{lastpage}

%\usepackage{biblatex}
%\addbibresource{bibliografia.bib}

%Encabezados y pie de página
\usepackage{fancyhdr}               
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Plan de gestión, análisis, diseño y memorial del proyecto} %No cabe lo de Juego online <<Guiñote>>
\fancyfoot[L]{Grupo 11 | Susan L. Graham}
\fancyfoot[R]{\thepage \hspace{1pt} de \pageref{LastPage}}

\renewcommand{\headrulewidth}{2pt}
\renewcommand{\footrulewidth}{1pt}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Plan de gestión, análisis, diseño y memorial del proyecto <<Juego online "Guiñote">>},                   
%    bookmarks=true,
}


\title{Plan de gestión, análisis, diseño y memorial del proyecto}                            
\author{Javier Herrer Torres}      
\date{Febrero 2021}                            

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{Juego online <<Guiñote>>}
            
        \vspace{0.5cm}
        \LARGE
		Plan de gestión, análisis, diseño y memorial del proyecto
		
        \vspace{1.5cm}
            
        \textbf{Mario Chavanel Moreno} (NIP: 679551)\\
        \textbf{Javier Fuster Trallero} (NIP: 626901)\\
        \textbf{Daniel Gracia Pardo} (NIP: 756128)\\
        \textbf{Javier Herrer Torres} (NIP: 776609)\\
        \textbf{Daniel Pérez Ramírez} (NIP: 756558)\\
        \textbf{Samuel Torres Fau} (NIP: 780505)
        
        \vfill
            
    	%Cambiar logotipo EINA por logo identificativo
    	\includegraphics[width=0.6\textwidth]{./images/logo.png}
            
        \vspace{1.5cm}
            
        
         Grupo 11 | Susan L. Graham\\
        \href{https://github.com/UNIZAR-30226-2021-11}{https://github.com/UNIZAR-30226-2021-11}
            
        \vspace{1.5cm}
 
    \end{center}
\end{titlepage}

\tableofcontents

\section{Introducción}
%Resumen del proyecto, propósito, alcance, objetivos, entregables e hitos principales. Alrededor de una página es suficiente. No olvidar una breve descripción de la estructura del resto del documento.

\section{Organización del proyecto}
%Equipo del proyecto: integrantes del mismo, roles y responsabilidades. Qué hace dentro del proyecto cada miembro del equipo. Aunque es normal que todo el mundo haga varias cosas, también es importante que haya responsables definidos para las tareas importantes. Es importante designar a un director o directora de proyecto.
El equipo encargado del proyecto está compuesto por Javier Herrer Torres, Javier Jesús Fuster Trallero, Daniel Pérez Ramírez, Samuel Torres Fau, Mario Chavanel Moreno y Daniel Gracia Pardo. \\A su vez, se han creado tres grupos de trabajo para cada una de las 3 principales partes de las que consta el proyecto:
\subsection{Backend}
Este grupo está compuesto por Javier Herrer y Javier Fuster. El objetivo principal de este grupo es el desarrollo del backend, el sistema que se encarga de gestionar las partidas de guiñote (interfaces, lógica de juego, etc). Las aplicaciones realizadas por los otros grupos se conectarán a este sistema, que ofrecerá las distintas funcionalidades indicadas en el análisis de requisitos presente en este mismo documento.

\subsection{Aplicación Web}
Este grupo está compuesto por Mario Chavanel y Daniel Gracia, y tiene el objetivo de desarrollar el cliente web que permitirá jugar al guiñote desde navegador, conectándose al backend desarrollado por el primer grupo.

\subsection{Aplicación android}
Grupo compuesto por Daniel Pérez y Samuel Torres, con la finalidad de desarrollar la aplicación android que, al igual que la aplicación web, se conectará al backend para permitir jugar desde los smartphones con sistema operativo android.

Pese a que estén definidos los grupos y los integrantes de cada uno de estos, dado que la carga de trabajo necesaria para el desarrollo de alguna de las partes del sistema es mayor en ciertos grupos que en otros, en algunos momentos se podrá apoyar en el desarrollo de componentes de grupos ajenos.

\subsection{Director del proyecto}
El director del proyecto elegido por el grupo es Javier Herrer, mediante una votación improvisada con resultado unánime.

\subsection{Actas de reunión}
El encargado de la realización de las actas de las diferentes reuniones llevadas a cabo y de futuras reuniones es Mario Chavanel.

\subsection{Memoria}
En cuanto a la realización de la memoria no se ha establecido un responsable para la misma, cada grupo redactará y documentará las partes que le correspondan, y el resto de aspectos comunes del proyecto serán repartidos en los integrantes del mismo.

\section{Plan de gestión del proyecto}
\subsection{Procesos}
%En esta sección se describe cómo se llevarán a cabo distintas tareas que hay que realizar en distintos momentos del proyecto.
\subsubsection{Procesos de inicio}
%Cómo se van a identificar y asignar recursos (p.ej. conseguir servidores en cloud o teléfonos móviles para pruebas, pero también registrarse para acceder a API que se quieran integrar o a herramientas online que se quieran usar etc.).

%Cómo se va a abordar la formación inicial de los miembros del equipo (revisar qué tecnologías se van a usar, qué componentes se van a integrar, con qué API hay que conectar y quiénes tienen que formarse, o autoformarse, en todas esas cosas y de qué manera (hacer algún curso online, planificar algo de tiempo para auto-formación con tutoriales y documentación etc.).

\subsubsection{Procesos de ejecución y control}
%Cómo se llevarán a cabo las comunicaciones internas, el registro de las decisiones tomadas en reuniones, la redacción de las actas etc.

%Cómo se van a determinar las tareas a realizar y el reparto de las mismas a integrantes del equipo en el día a día.

%Cómo se abordarán los temas de gestión del equipo humano (p.ej. la resolución de disputas).

%Qué se va a hacer respecto a medidas de progreso y monitorización del estado del proyecto (qué se mira/mide, cada cuánto tiempo, qué se hace si se detectan problemas de rendimiento o avance insuficiente o desviaciones respecto al plan inicial...).

%Cómo se hará la entrega de resultados.


Las comunicaciones internas se realizarán mediante la aplicación de mensajería instantánea WhatsApp, a través del grupo creado a tal efecto. Además, se realizarán reuniones en el \textit{slot} acordado la primera semana, en el que todos los miembros están disponibles: martes de 12:00 a 14:00 (en la hora de seminario). El contenido de estas reuniones será recogido por Mario Chavanel Moreno, que se encargará de la redacción de actas cuyo contenido incluirá las decisiones tomadas.

Además, el equipo usará GitHub como herramienta de apoyo para la asignación de las tareas a realizar. El director del proyecto, Javier Herrer Torres, creará las \textit{issues} correspondientes. Además, podrá asignarla a un equipo en concreto (\textit{front-end} o \textit{back-end}) o podrán ser los propios integrantes los que se auto asignen las tareas que más les interesen.

Las posibles disputas que surjan sobre, por ejemplo, aspectos funcionales relevantes del proyecto, serán discutidas con todos los miembros del equipo dando razones a favor y en contra de tomar una determinada acción. Y, posteriormente, se someterá a votación escogiendo la opción con más votos.

También se empleará GitHub para el seguimiento del progreso y el estado del proyecto mediante \textit{Milestones} que permiten ver de forma gráfica este progreso. Además, GitHub proporciona gráficas y métricas en base a los \textit{commits} de los colaboradores.

Cuando un colaborador complete una tarea asignada, unirá sus cambios con la rama \textit{master} del repositorio marcando la \textit{issue} como cerrada. Las tareas podrán ser revisadas por el director del proyecto o por cualquier otro integrante relacionado con esa tarea.

\subsubsection{Procesos técnicos}

\subsubsection{Redacción de memorias y documentación}
Para el desarrollo de la memoria del proyecto y de todo el resto de documentos empleados se empleará el lenguaje de \LaTeX, ya que se trata de una lenguaje orientado a la creación de documentos escritos, y proporciona una alta calidad tipográfica.
Debido a la elección de este lenguaje, se trabaja sobre ficheros '.tex' directamente, empleando GitHub para el trabajo colaborativo, al igual que con el resto del código del proyecto. El compilador empleado para generar los ficheros PDF es MikTex.

\subsubsection{Empleo de GitHub}
Para el control de versiones y configuraciones va a hacerse uso de GitHub. Del mismo modo también será empleado para el trabajo colaborativo.


\subsubsection{Desarrollo del backend}
El backend va a crearse en el lenguaje de programación GoLang, por lo que el grupo responsable del mismo ha optado por emplear el IDE GoLand de JetBrains, ya que está específicamente enfocado en este lenguaje. La elección de GoLang se debe a la facilidad que ofrece para el despliegue de componentes web.%Justificar brevemente la elección de GoLang

En lo respectivo a la base de datos del backend, va a emplearse PostreSQL ya que, además de ser software libre, %Justificar brevemente la elección de PostgreSQL



\subsubsection{Desarrollo de la aplicación Android}
Para el desarrollo del cliente Android va a emplearse el lenguaje Java, ya que está ampliamente soportado en los dispostivos con sistema operativo Android y que ofrece un buen soporte para el desarrollo de aplicaciones nativas. Además, se empleará la base de datos de los teléfonos inteligentes para guardar la información de la aplicación, es decirse hará uso de SQLite

Respecto al desarrollo de la aplicación, va a trabajarse con Android Studio, ya que se trata de un IDE muy completo y que proporciona funcionalidades de gran utilidad, como la integración de emuladores Android, que facilitan la creación de aplicaciones Android.

\subsubsection{Desarrollo de la aplicación Web}
La aplicación web va a ser desarrollada en HTML y CSS, dado que son el estándar para el desarrollo web. Además se hará uso de JavaScript para ayudar a crear las funcionalidades del juego.

En cuanto al desarrollo del código, va a hacerse uso de Visual Studio Code, con los plugins pertinentes que faciliten el desarrollo web, como la visualización de las páginas HTML. Se ha decidido emplear este editor por el gran número de plugins de los que dispone, así como por la facilidad de uso de la herramienta en cuestión.
% Añadir decisiones y/o otros programas empleados.

\subsection{Planes}
%Un plan establece un objetivo y, en general, qué necesitamos para conseguirlo. Llevar a cabo los planes que se describan aquí requerirá aplicar los procesos descritos anteriormente, algunos una vez y otros muchas veces. Un plan suele incluir cuándo se llevan a cabo estos procesos (periódicamente, o en fechas concretas, o “al menos N veces” etc.) y quién es responsable (personas concretas a veces, pero generalmente roles) de hacerlos, o de asegurarse que se hacen.

\subsubsection{Plan de gestión de configuraciones}
%Convenciones de nombres (documentos) y estándares de código (guías de estilos).


%Responsable o responsables de las distintas actividades (puesta en marcha, apoyo al equipo, revisión de commits, copias de seguridad, control de las versiones entregadas a cliente...).

%Recursos: repositorios de control de versiones (cuáles, cuántos, permisos de acceso a los mismos) y sistema de gestión de incidencias.

%Procedimiento para realizar cambios al código fuente y los documentos técnicos: workflow de control de versiones utilizado, cuándo/cómo se permiten realizar commits al repositorio compartido, si tienen que ser aceptados por alguien previamente o no, qué hay que anotar en el sistema de gestión de incidencias, quién decide el estado de las incidencias, en qué estados puede estar una incidencia etc.

\subsubsection{Plan de construcción y despliegue del software}
%Cómo se construye e integra el software: si hay scripts de construcción automatizada o no (en ese caso qué se usa, y cómo se garantiza que todos los participantes compilan igual y con las mismas dependencias), qué se incluye en la construcción (descarga y actualización de dependencias, compilación, ejecución de tests automáticos...) y cada cuánto se construye (compila, integra, prueba) el sistema completo, cómo se configuran los computadores de los desarrolladores.

%Cómo se despliega el software más allá de las máquinas de desarrollo: contenedores, máquinas virtuales, servidor en cloud etc. y cómo se configuran esos entornos (rutas, usuarios y contraseñas, puertos y otros elementos).

El \textit{back-end} de la aplicación se encontrará desplegado dentro de un contenedor de Docker, que recibirá las peticiones mediante \emph{nginx}. Estará situado en un servidor, ya sea de uno de los integrantes o de un proveedor de este tipo de servicios como AWS. El objetivo es que, los desarrolladores de \textit{front-end} puedan probar el correcto funcionamiento de la aplicación realizando peticiones a un mismo servidor.

Este servidor se actualizará siguiendo una \emph{integración continua}. Es decir, cada \textit{commit} en la rama \textit{main} del repositorio de \textit{back-end} provocará la ejecución de un script de construcción automatizada para modificar el despliegue. Esto garantiza que todos los participantes puedan observar el resultado al mismo tiempo que programa.

Los computadores de los desarrolladores estarán configurados con el mismo IDE: Android Studio para la aplicación móvil, IntelliJ para la aplicación web, y GoLand para el \textit{back-end} . Además, deberán hacer uso de GitHub para subir los cambios que realicen.

La aplicación móvil se encontrará disponible en la tienda de aplicaciones de Android, Google Play. La aplicación web será accesible mediante una URL desde un navegador como Google Chrome. Todo el almacenamiento de información relativa a usuarios, contraseñas, etc. se encontrará en el servidor común al que podrán realizar peticiones en las rutas especificadas.


\subsubsection{Plan de aseguramiento de la calidad}
%Guías para la documentación de diseño del software y otros documentos del proyecto, guías para el diseño gráfico de las GUI (estética, usabilidad...).

%Actividades de control de calidad del código que se realizarán: revisiones de código por pares, revisiones de requisitos o diagramas UML por pares, tipos de tests automáticos o manuales que se llevarán a cabo.
Pruebas de sobrecarga del servidor, para comprobar cual es la carga de trabajo y clientes que soporta el sistema desarrollado y evaluar si es suficiente o es necesario modificar la arquitectura para generar otro sistema más escalable o adquirir más recursos hardware. Esta prueba se realizará una vez esté completo el servidor y se pueda comunicar con los clientes.

Pruebas de integración del API con las aplicaciones web y android. Estas pruebas consistirán en probar que se establece la comunicación entre el servidor y los clientes y que las peticiones y respuestas son correctas. Esta prueba se debe realizar una vez finalizada la comunicación entre clientes y está prevista para la primera iteración.

Inspección de código para evitar posibles errores que no ha detectado el compilador o se pueden producir en tiempo de ejecución. Estas revisiones se realizarán por parejas, cuando se añada una funcionalidad nueva al sistema la pareja asignada revisará el código.

Pruebas de usabilidad de las interfaces, para verificar que se puede acceder a todos los requisitos especificados y no existe ningún bug, alguna secuencia de acciones que puedan ocasionar algún error en la interfaz o que exista alguna pantalla inaccesible.La prueba se realizará una vez finalizada la interfaz.

Pruebas de funcionamiento para cada nuevo requisito que se realice en el sistema. Estas pruebas se realizarán a lo largo de toda la fase de desarrollo cada vez que se termine de implementar un requisito o una nueva funcionalidad.

\subsubsection{Calendario del proyecto y división del trabajo}
%Diagrama de Gantt que recoja las tareas a realizar. Tened en cuenta que trabajáis con dos iteraciones y por tanto que hay una entrega intermedia y una final, y esto debe estar reflejado en este diagrama. Tened en cuenta que es normal que lo tengáis que actualizar conforme avance el proyecto (cuándo y cómo establezcáis en la sección 3.1.2 (Procesos de ejecución y control).
	%Debe quedar claro qué requisitos van a estar completados en la primera iteración y cuáles en la segunda. Es posible que para la primera iteración no se planifique completar ningún requisito, pero en ese caso tiene que planificarse qué se hará y que faltará por hacer para cada requisito.

%División del trabajo en partes (los módulos del software a desarrollar, pero también la documentación, el diseño gráfico, instalaciones o despliegues, pruebas manuales etc.) y reparto de los mismos entre el equipo de desarrollo, al menos a alto nivel (el reparto de labores concretas en el día a día no se detalla aquí, pero hay que explicar bajo qué criterios y quién/cómo se hace eso en la sección 3.1.2 (Procesos de ejecución y control). Debe haber una correspondencia con las tareas que aparecen en el diagrama de Gantt (que no necesariamente tiene que ser una relación uno a uno).
	%Verificad que esta división del trabajo cubre todos los requisitos.

\section{Análisis y diseño del sistema}
\subsection{Análisis de requisitos}
%Hay que completar y detallar los requisitos preliminares incluidos en la propuesta técnica y económica. Recordad que los requisitos deben ser completos, concretos, medibles cuando tenga sentido y lo menos ambiguos posible. También es importante que estén identificados para facilitar su trazabilidad.

\subsection{Diseño del sistema}
%Diagramas arquitecturales (de módulos, de componentes y conectores, de distribución), patrones de diseño y estilos arquitecturales que se aplicarán. Las interfaces (de módulos y de componentes) son especialmente importantes. También lo son los protocolos de comunicación entre componentes.


El sistema está pensado para facilitar el despliegue en diferentes máquinas
fácilmente usando Docker.

\subsubsection{Diagramas arquitecturales}
%Tecnologías elegidas (lenguajes de programación, componentes que se integrarán, API web externas con las que se conectará etc.).

% Tabla de componentes
%\begin{figure}[htb]
%
%    \centering
%    \includegraphics[width=0.8\textwidth]{}
%    \label{fig:diag_componentes}
%    \caption{}
%\end{figure}


\subsubsection{Tecnologías elegidas}

El proyecto se va a desarrollar con diferentes lenguajes de programación, esto se hace para aprovechar las 
fortazalezas de cada uno en su campo de aplicación así como la experiencia disponible en el equipo de desarrollo.


\paragraph*{Aplicación Web}

Está dividida en vista y controlador, el modelo del juego estará implementada en el backend, 
la lógica de la interfaz web será implementada con JavaScript nativo en todos los navegadores. 
La interfaz será implementada con las tecnologías tradicionales web, HTML y CSS.

\paragraph*{Aplicación Android}
El desarrollo de aplicaciones Android nativo, se puede realizar mediante dos tecnologías:

\begin{itemize}
    \item Java
    \item Kotlin
\end{itemize}

Debido a que en el equipo de desarrollo se tiene mucha más experiencia con Android que con Kotlin, y realizar 
el desarrollo con un lenguaje diferente a estos dos representa una serie de complicaciones no deseadas, 
posibles incompatibilidades de llamadas, necesidad de librerías extensas y manejo de dependencias adicionales.

\paragraph*{RESTful API}

Para este componente se han barajado distintas opciones, ya que no está tan marcado por la plataforma sobre la que se despliega como los componentes de la interfaz.
\begin{itemize}
    \item Java, es uno de los lenguajes más utilizados en backend, existe familiaridad en el equipo con el aunque es un lenguaje con mucha verbosidad, requiere
        de una máquina virtual para su ejecución. Así mismo las implementaciones nativas de servidores web requieren del despliegue de un servidor en Tomcat con
        las implicaciones que pueda tener.
    \item Golang, un lenguaje relativamente novedoso, ampliamente utilizado por empresas trabajando en desarrollo de tecnologías en la nube, es un lenguaje 
        compilado, por lo que no requiere de una máquina virtual, y a su vez posee unas librerías estandar pensadas para el desarrollo de aplicaciones que 
        necesitan conectividad, además el equipo de desarrollo también tiene experiencia en él.
\end{itemize}

Debido a que es necesario el diseño y desarrollo de una API RESTful en poco tiempo y se posee el mismo conocimiento en ambos, se ha decidido utilizar Golang ya que su librería estándar presenta grandes facilidades a la hora de crear servicios web y su despliegue consiste en ejecutar el binario creado.

\paragraph*{Servidor Web}

Como servidor web tras la elección de Golang como lenguaje para la API se nos presentan dos opciones:

\begin{itemize}
    \item Un servidor web tradicional como NGINX o Apache.
    \item Creación de nuestro propio servidor.
\end{itemize}

Debido a las restricciones de los plazos, se utilizará NGINX para agilizar el despliegue, debido a que permite el despliegue de diferentes servicios en la misma
máquina física.

Actuará como proxy inverso para todos los servicios disponibles en la máquina. La conexión se realizará siempre mediante el protocolo HTTPS, para asegurar la
privacidad de las conexiones.

\paragraph*{Base de datos}

En primer lugar se ha decidido entre usar una base SQL o NoSQL, debido a que nuestro modelo de datos no requiere de la realización de grandes consultas 
SQL, ni la necesidad del escalado que ofrecen las NoSQL, se ha optado por la opción más familiar, una base de datos relacional tradicional.

La implementación a elegir:

\begin{itemize}
    \item PostrgeSQL
    \item MySQL
\end{itemize}

Se ha optado por PostgreSQL porqué el equipo tiene mayor experiencia en ella y es ampliamente usada en servicios en producción.



%Otros aspectos técnicos de interés (p.ej. si hay base de datos si va a ser SQL o NoSQL, si hay una API Web va a ser REST[ful] o no, si algunas de las operaciones van a ser asíncronas o no, si va a ser una aplicación móvil o de escritorio será nativa o se van a usar tecnologías web, cómo se van a considerar los requisitos de seguridad o de prestaciones, cómo y dónde se harán las instalaciones y despliegues etc.)

%Hay que justificar todas las decisiones de diseño. Esto exige contestar a dos preguntas sobre cada decisión: ¿qué alternativas se barajaron? y ¿por qué se eligió una y no las otras?

\appendix
\section{Anexo: Reglamento del Guiñote}
Fuente: \href{https://www.ludoteka.com/clasika/guinote.html}{Ludoteka.com}

\subsection*{Origen e historia}
El Guiñote es un juego de baraja española perteneciente a la amplia familia del tute, juegos en los que se trata de ir consiguiendo bazas, con un palo dominante o palo de triunfo. El guiñote está especialmente arraigado en Aragón y algunas zonas de Navarra y Castilla.

\subsection*{Descripción}
Se trata de un juego de baraja española de 40 cartas. Se juega entre cuatro personas, formando dos parejas. Dado que las reglas son en muchos aspectos muy similares a las del Tute, en la explicación de las mismas se harán referencias a este último juego.

\subsection*{Objetivo}
El objetivo general del juego es conseguir ganar antes que la pareja rival el número de <<cotos>> pactado inicialmente, cotos constituidos a su vez por el 3 puntos/manos ganadoras. El objetivo concreto para ganar cada una de esas manos es sumar el mayor número de puntos posible con las cartas ganadas en cada baza para superar los 100 tantos necesarios para ganarla. Habrá que intentar llevarse un gran número de bazas que reúnen cartas con la puntuación más alta posible. A estos efectos el valor de cada carta es el que sigue: As (11 puntos), Tres (10 puntos), Rey (4 puntos), Sota (3 puntos) y Caballo (2 puntos). El resto de cartas no tienen valor puntuable.

Existe una jerarquía entre las cartas de un mismo palo de cara a saber cuál es la carta que vence en cada una de las bazas. Es la siguiente, de mayor a menor: As, Tres, Rey, Sota, Caballo, Siete, Seis, Cinco, Cuatro y Dos. A su vez existe una jerarquía entre palos: el palo de mayor rango es el de triunfo (cambia en cada mano), en segundo lugar está el palo de salida (cambia en cada baza), y finalmente están los dos palos restantes.

\subsection*{Desarrollo del juego}
Cada mano tiene dos fases bien diferenciadas. Una primera fase en la que las reglas son muy similares a las del juego de la Brisca y una segunda en la que las reglas son muy similares al propio juego del Tute.
\subsubsection*{Comienzo de la partida y de cada una de las manos}
Se echa a suertes para saber quién es el que reparte por primera vez y quién es mano (el que se sitúe a la derecha del que reparte).

En las siguientes manos será mano el jugador situado a la derecha de quien se llevó las diez de últimas en la mano anterior.

En cada mano el que reparte dará a cortar la baraja al jugador situado a su izquierda, y seguidamente repartirá 6 cartas a cada jugador una a una y de izquierda a derecha. Cuando haya terminado de repartir las cartas, levantará la siguiente dejándola visible junto al mazo durante toda la mano: esa carta será la que pinte, la que marque el triunfo en esa mano.

Cada una de las manos consta de 10 bazas. Una baza es el conjunto de cartas (una por cada jugador) que lanzan sobre el tapete los jugadores en su turno respectivo. Cada vez que se completa una baza habrá un jugador que la gana, que se la lleva.
\subsubsection*{Primera fase de la mano}
Mientras queden cartas en el mazo (durante las cuatro primeras manos), el que va de mano echará al centro del tapete una de sus cartas (la que él quiera), y los demás, de izquierda a derecha, deberán echar una más cada uno, la que ellos quieran, sin limitaciones u obligaciones de ningún tipo respecto a cuál echar.

\subsubsection*{Recoger las bazas}

La baza se la llevará el jugador que hubiera echado la carta más alta del palo de triunfo, y si no hay triunfos sobre el tapete, la carta más alta del palo de salida.

En las bazas sucesivas, dentro de una misma mano, el jugador que se ha llevado la última baza es el que empezará lanzando la 1ª carta de la baza siguiente.

Antes de lanzar nuevamente las cartas para jugar una nueva baza, todos los jugadores tomarán una carta de encima del mazo, empezando por el que ganó la baza anterior, de forma que siempre tengan seis cartas en la mano.

\subsubsection*{Cambio de cartas}

Cuando un jugador tuviera en su mano durante el juego el siete del palo de triunfo, podrá cambiarlo por la carta que pinte si ésta fuera una carta de valor (As, Tres, Rey, Sota o Caballo). Este cambio podrá hacerse justo tras haber ganado una baza y antes de proceder a robar la carta correspondiente del mazo.

Para obtener el cambio de carta debe pulsarse en cualquier momento la carta que marca el triunfo, de modo que el programa realiza el cambio en cuanto éste es posible.

\subsubsection*{Segunda fase de la mano o fase de Arrastre}

Lógicamente, conforme avance el juego en una mano, las cartas del mazo se acabarán y llegará un momento en que no habrá cartas para robar: en las seis últimas bazas se jugará sólo con las cartas que tuvieran en la mano. Cuando las cartas del mazo se acaban, el último jugador toma la carta que señala el palo de triunfo.

En esta fase cambian las normas en cuanto a obligatoriedad al echar cartas, pasando a utilizar las normas del tute (con alguna pequeña diferencia). El jugador que hubiera ganado la última baza de la fase anterior echa al centro del tapete una de sus cartas (la que él quiera), que será la que indique el palo de salida de esa baza, y los demás, de izquierda a derecha, deberán echar una más cada uno, siguiendo las reglas siguientes:

\begin{itemize}
	\item Obligación de \textbf{montar} y de \textbf{asistir}: si un jugador, en su turno, tuviera cartas del palo de salida estará obligado a ASISTIR (echar carta de ese palo), y además, si pudiera, a MONTAR (echar una carta del palo de salida que supere a las cartas que están sobre el tapete).
	\item Obligación de \textbf{fallar}: si un jugador, en su turno, no pudiera asistir (no tuviera carta del palo de salida) deberá FALLAR (echar una carta del palo de triunfo) siempre que superase a las que hubiera sobre el tapete.
	\item Si la baza la va ganando la pareja no hay obligación de montar ni fallar, sino tan sólo la obligación de asistir al palo de salida. Ésta es una particularidad que distingue al Guiñote del Tute en esta fase del juego.
	\item Si un jugador no tuviera cartas para asistir ni para fallar superando las cartas del tapete, podrá entonces echar la carta que quiera.
	\item La baza se la llevará el jugador que hubiera echado la carta más alta en la jerarquía arriba indicada.
	\item En las bazas sucesivas, dentro de una misma mano, el jugador que se ha llevado la última baza es el que empezará lanzando la 1ª carta de la baza siguiente.
\end{itemize}

\subsubsection*{Cánticos}

Durante el desarrollo de la mano, si un jugador tuviera el rey y la sota de un mismo palo, podrá realizar un cántico, es lo que se denomina cantar las 40 (si se trata de la sota y el rey del palo de triunfo) o cantar las 20 (si se trata de rey y sota de cualquier otro palo). Deberá indicar tal circunstancia precisando el palo en el que canta las 20 (20 en oros, copas, espadas o bastos) o si canta las 40 bastará que lo indique sin necesidad de indicar el palo, ya que en cada mano sólo existe un palo de triunfo. Si el cántico se hace durante la fase de arrastre, no es necesario indicar el palo del que se trata, salvo que así lo solicite el propio compañero, en cuyo caso sí deberá indicarse el palo concreto.

Los cánticos asignan los tantos que indican sus nombres (20 ó 40) a efectos del recuento final de la mano.

Los cánticos pueden realizarse cuando la propia pareja ha realizado la última baza.

\subsubsection*{Puntuación por las bazas}

Una vez que se han completado todas las bazas de una mano, se procederá al recuento de los puntos obtenidos por cada jugador en esa mano por las bazas ganadas, que se sumarán a los ya obtenidos por razón de los cánticos.

Los tantos serán sumados a todos los efectos por parejas.

La pareja que hubiera llevado la última baza de una mano sumará 10 tantos más (10 de últimas)

El número total de puntos que suman las cartas de la baraja es 120. Lógicamente, además, en todas las manos habrá 10 puntos de últimas. Por otro lado, el máximo de puntos posible por razón de los cánticos es 100.

La pareja que supere los 100 tantos ganará la mano.

Si ambas parejas superan dicha cantidad no gana necesariamente la qué más tantos haya obtenido:

\begin{itemize}
	\item Si una pareja no alcanza 30 puntos sin contar los cantes, pierde
	\item Si ambas parejas además de superar los 100 tantos, superan los 30 tantos sin contar los cantes, gana quien se lleva las 10 últimas.
\end{itemize}

Si ninguna de las parejas supera los 100 tantos en una mano se jugará una mano más llamada "de vueltas". No es preciso que en la mano de vuelta sean jugadas todas las cartas, sino que el ganador de cada baza tiene la opción de anunciar que ha superado los 100 puntos, dándola así por finalizada. Si efectivamente, sumando los puntos de la mano anterior, supera los 100 puntos, la mano es suya; en caso contrario, será para la pareja oponente.

\subsection*{Final de la partida}

Gana la partida aquella pareja que antes consiga alcanzar el número de cotos pactado inicialmente, formado a su vez por tres manos/puntos.

\end{document}
